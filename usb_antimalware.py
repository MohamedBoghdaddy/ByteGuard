import os
import hashlib
import tkinter as tk
from tkinter import messagebox
import psutil
import clamd
from threading import Thread
import time
from dotenv import load_dotenv
import requests
import joblib
import tensorflow as tf
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import IsolationForest

# Load environment variables
load_dotenv()
API_KEY = os.getenv("VIRUSTOTAL_API_KEY")

# VirusTotal API URLs
VIRUSTOTAL_API_URL = "https://www.virustotal.com/api/v3/files/"
VIRUSTOTAL_UPLOAD_URL = "https://www.virustotal.com/api/v3/files"
VIRUSTOTAL_ANALYSIS_URL = "https://www.virustotal.com/api/v3/analyses/"

# List of known bad file extensions often used by malware
SUSPICIOUS_EXTENSIONS = ['.exe', '.vbs', '.bat', '.lnk', '.pif', '.scr', '.com']

# Define autorun file to look for
AUTORUN_FILENAME = 'autorun.inf'

# Set up ClamAV client
cd = clamd.ClamdUnixSocket()

# Load pre-trained models
try:
    nlp_model = joblib.load('nlp_malware_model.pkl')
    vectorizer = joblib.load('tfidf_vectorizer.pkl')
    malware_model = tf.keras.models.load_model('malware_cnn.h5')
    anomaly_model = joblib.load('anomaly_detection_model.pkl')
    ai_model = joblib.load('malware_detection_model.pkl')
except Exception as e:
    print(f"Error loading models: {e}")

# Function to calculate MD5 hash of a file
def calculate_md5(file_path):
    with open(file_path, 'rb') as f:
        file_hash = hashlib.md5()
        while chunk := f.read(8192):
            file_hash.update(chunk)
    return file_hash.hexdigest()

# AI-based script file analysis using NLP
def analyze_script_file(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
        script_content = f.read()
    features = vectorizer.transform([script_content])
    prediction = nlp_model.predict(features)
    return prediction == 1

# Extract file features such as size and entropy
def extract_features(file_path):
    size = os.path.getsize(file_path)
    with open(file_path, 'rb') as f:
        data = f.read()
    entropy = calculate_entropy(data)
    return [size, entropy]

# Function to calculate file entropy
def calculate_entropy(data):
    from collections import Counter
    byte_counts = Counter(data)
    entropy = -sum((count / len(data)) * (count / len(data)).bit_length() for count in byte_counts.values())
    return entropy

# AI-based malware classification using deep learning
def classify_file_with_dl(file_path):
    features = extract_features(file_path)
    prediction = malware_model.predict([features])
    return prediction[0] > 0.5

# AI-based malware detection using machine learning
def scan_file_with_ai(file_path):
    features = extract_features(file_path)
    prediction = ai_model.predict([features])
    return prediction[0] == 1

# VirusTotal: Upload file and scan
def upload_and_scan_file(file_path):
    headers = {"x-apikey": API_KEY}
    with open(file_path, 'rb') as file:
        files = {'file': (file_path, file)}
        response = requests.post(VIRUSTOTAL_UPLOAD_URL, headers=headers, files=files)
    if response.status_code == 200:
        return response.json().get('data', {}).get('id')
    return None

# VirusTotal: Get report based on scan ID
def get_scan_report(scan_id):
    headers = {"x-apikey": API_KEY}
    url = f"{VIRUSTOTAL_ANALYSIS_URL}{scan_id}"
    response = requests.get(url, headers=headers)
    return response.json() if response.status_code == 200 else None

# Real-time detection of USB insertion
def monitor_usb(gui_output, auto_run=False):
    existing_drives = set(psutil.disk_partitions())
    while True:
        current_drives = set(psutil.disk_partitions())
        if current_drives != existing_drives:
            added_drives = current_drives - existing_drives
            for drive in added_drives:
                gui_output.insert(tk.END, f"USB drive {drive.device} detected!")
                if auto_run:
                    gui_output.insert(tk.END, "Auto-scanning enabled. Scanning now...")
                    scan_system(gui_output)
            existing_drives = current_drives
        time.sleep(5)

# GUI Creation with tkinter
class AntiMalwareApp:
    def __init__(self, root):
        self.root = root
        self.root.title("USB Anti-Malware Scanner")
        self.root.geometry("600x450")
        
        frame = tk.Frame(self.root)
        frame.pack(pady=20)
        
        self.output = tk.Listbox(frame, width=70, height=18)
        self.output.pack(side=tk.LEFT)
        scrollbar = tk.Scrollbar(frame, orient=tk.VERTICAL)
        scrollbar.config(command=self.output.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.output.config(yscrollcommand=scrollbar.set)
        
        self.scan_button = tk.Button(self.root, text="Manual Scan USB", command=self.manual_scan)
        self.scan_button.pack(pady=10)
        
        self.auto_scan_var = tk.BooleanVar()
        self.auto_scan_check = tk.Checkbutton(self.root, text="Enable Auto-Scan", variable=self.auto_scan_var)
        self.auto_scan_check.pack(pady=5)
        
        self.monitor_thread = Thread(target=monitor_usb, args=(self.output, False))
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
        self.output.insert(tk.END, "Monitoring USB connections...")
    
    def manual_scan(self):
        self.output.insert(tk.END, "Manual scan started.")
        scan_system(self.output)

if __name__ == '__main__':
    root = tk.Tk()
    app = AntiMalwareApp(root)
    root.mainloop()
